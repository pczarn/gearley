<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `optional` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, optional">

    <title>optional - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'optional', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>optional</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/optional/lib.rs.html#6-1409' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Space-efficient optional values</p>

<p>Type <code>OptionBool</code> represents an optional boolean value, similar to
 <code>Option&lt;bool&gt;</code>. Most function implementations are similar or equal.
 Note that the <code>map_bool(..)</code> <code>and_bool(..)</code>, <code>and_then_bool(..)</code>,
<code>or_bool(..)</code> and <code>or_else_bool(..)</code> functions are working similar to the
 methods without the <code>_bool</code> suffix, but require and return <code>OptionBool</code>
 instead of <code>Option&lt;bool&gt;</code>. This allows people to stay within the type.</p>

<p>The <code>OptionBool</code> type is expected to require only 1 byte of storage:</p>

<pre class='rust rust-example-rendered'>
 <span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>1</span> <span class='op'>==</span> <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>optional</span>::<span class='ident'>OptionBool</span><span class='op'>&gt;</span>());</pre>

<p>Then there is the <code>Optioned&lt;T&gt;</code> type which wraps a type <code>T</code> as an optional
 value of <code>T</code> where one particular value represents None. <code>Optioned&lt;T&gt;</code>
 requires the exact same space as T:</p>

<pre class='rust rust-example-rendered'>
 <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>optional</span>::<span class='ident'>Optioned</span><span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;&gt;</span>() <span class='op'>==</span>
     <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;</span>());
 <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>optional</span>::<span class='ident'>Optioned</span><span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;&gt;</span>() <span class='op'>==</span>
     <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>());
 <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>optional</span>::<span class='ident'>Optioned</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span>() <span class='op'>==</span>
     <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>());</pre>

<p>There are implementations for <code>u8..64,usize</code> with <code>std::u..::MAX</code>
 representing None, also for <code>i8..64,isize</code> with <code>std::i..::MIN</code>
 representing None, and for <code>f32, f64</code> with <code>std::f..::NAN</code> representing
 None.</p>

<p>Using Optioned for your own types is as simple as implementing <code>Noned</code> for
 your type, provided that your type is already Copy and Sized.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.IterBool.html'
                                  title='optional::IterBool'>IterBool</a></td>
                           <td class='docblock short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Optioned.html'
                                  title='optional::Optioned'>Optioned</a></td>
                           <td class='docblock short'>
                                <p>An <code>Option&lt;T&gt;</code>-like structure that takes only as much space as the enclosed
value, at the cost of removing one particular <code>None</code> value from the value
domain (see <code>Noned</code>)</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.OptionedIter.html'
                                  title='optional::OptionedIter'>OptionedIter</a></td>
                           <td class='docblock short'>
                                
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='enum' href='enum.OptionBool.html'
                                  title='optional::OptionBool'>OptionBool</a></td>
                           <td class='docblock short'>
                                <p>The <code>OptionBool</code> type, a space-efficient Option<bool> replacement</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.Noned.html'
                                  title='optional::Noned'>Noned</a></td>
                           <td class='docblock short'>
                                <p>A trait whose implementation for any type <code>T</code> allows the use of
<code>Optioned&lt;T&gt;</code> where <code>T</code> is bound by both <code>Sized</code> and <code>Copy</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.OptEq.html'
                                  title='optional::OptEq'>OptEq</a></td>
                           <td class='docblock short'>
                                <p>Equality within Optioned</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.OptOrd.html'
                                  title='optional::OptOrd'>OptOrd</a></td>
                           <td class='docblock short'>
                                <p>Ordering within Optioned</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.none.html'
                                  title='optional::none'>none</a></td>
                           <td class='docblock short'>
                                <p>Create a <code>None Optioned&lt;T&gt;</code>. Note that the type must be inferrible
 from the context, or you&#39;d need to call with <code>::&lt;T&gt;</code> where <code>T</code> is
 the specific type.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.some.html'
                                  title='optional::some'>some</a></td>
                           <td class='docblock short'>
                                <p>Create an <code>Optioned&lt;T&gt;</code> that is <code>some(t)</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.wrap.html'
                                  title='optional::wrap'>wrap</a></td>
                           <td class='docblock short'>
                                <p>Wrap a <code>T</code> into an <code>Optioned&lt;T&gt;</code>, regardless of its None-ness.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "optional";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>